<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handwriting Stroke Capture with Automatic Word Prompts</title>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        button { cursor: pointer; }
        input[type="range"] { width: 100%; }
        canvas { border: 1px solid #ccc; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const SAMPLING_INTERVAL = 2;

        const Button = ({ onClick, children }) => (
            <button
                onClick={onClick}
                style={{
                    padding: '8px 16px',
                    backgroundColor: '#2D3748',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    marginRight: '8px'
                }}
            >
                {children}
            </button>
        );

        const Input = ({ type, accept, onChange, value, placeholder, style, min, max, id }) => (
            <input
                type={type}
                accept={accept}
                onChange={onChange}
                value={value}
                placeholder={placeholder}
                style={{ ...style, padding: '4px', marginBottom: '8px' }}
                min={min}
                max={max}
                id={id}
            />
        );

        const Textarea = ({ value, readOnly, style, placeholder }) => (
            <textarea
                value={value}
                readOnly={readOnly}
                style={{ ...style, padding: '4px', width: '100%', height: '200px' }}
                placeholder={placeholder}
            />
        );

        const Label = ({ htmlFor, children }) => (
            <label htmlFor={htmlFor} style={{ display: 'block', marginBottom: '4px' }}>
                {children}
            </label>
        );

        const Slider = ({ id, min, max, step, value, onChange }) => (
            <input
                id={id}
                type="range"
                min={min}
                max={max}
                step={step}
                value={value}
                onChange={onChange}
                style={{ width: '100%' }}
            />
        );

        const ErrorMessage = ({ message }) => (
            <div style={{ backgroundColor: '#FEE2E2', border: '1px solid #F87171', color: '#B91C1C', padding: '8px', borderRadius: '4px', marginBottom: '16px' }}>
                <span>{message}</span>
            </div>
        );

        const HandwritingStrokeCapture = () => {
            const [strokes, setStrokes] = React.useState([]);
            const [currentStroke, setCurrentStroke] = React.useState([]);
            const [backgroundImage, setBackgroundImage] = React.useState(null);
            const [imagePosition, setImagePosition] = React.useState({ x: 0, y: 0 });
            const [imageScale, setImageScale] = React.useState(1);
            const [isDrawing, setIsDrawing] = React.useState(false);
            const [exportedData, setExportedData] = React.useState('');
            const [author, setAuthor] = React.useState('');
            const [asciiSequence, setAsciiSequence] = React.useState('');
            const [errorMessage, setErrorMessage] = React.useState('');
            const [dataset, setDataset] = React.useState([]);
            const [wordBank, setWordBank] = React.useState([]);
            const [currentPrompt, setCurrentPrompt] = React.useState('');
            const [wordCount, setWordCount] = React.useState(1);
            const [samplingMode, setSamplingMode] = React.useState('random');
            const [startIndex, setStartIndex] = React.useState(0);
            const [currentIndex, setCurrentIndex] = React.useState(0);
            const [displayIndex, setDisplayIndex] = React.useState(0);

            const canvasRef = React.useRef(null);
            const lastPointRef = React.useRef(null);
            const lastSampledPointRef = React.useRef(null);

            const drawStrokes = React.useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (backgroundImage) {
                    ctx.save();
                    ctx.translate(imagePosition.x, imagePosition.y);
                    ctx.scale(imageScale, imageScale);
                    ctx.drawImage(backgroundImage, 0, 0);
                    ctx.restore();
                }

                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 3);
                ctx.lineTo(canvas.width, canvas.height / 3);
                ctx.moveTo(0, 2 * canvas.height / 3);
                ctx.lineTo(canvas.width, 2 * canvas.height / 3);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.strokeStyle = '#2F4F4F';
                ctx.lineWidth = 2;
                strokes.forEach(stroke => {
                    if (stroke.length > 0) {
                        ctx.beginPath();
                        ctx.moveTo(stroke[0][0], stroke[0][1]);
                        stroke.forEach(point => {
                            if (point[2] === 1) {
                                ctx.lineTo(point[0], point[1]);
                            } else {
                                ctx.moveTo(point[0], point[1]);
                            }
                        });
                        ctx.stroke();
                    }
                });

                if (currentStroke.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(currentStroke[0][0], currentStroke[0][1]);
                    currentStroke.forEach(point => {
                        if (point[2] === 1) {
                            ctx.lineTo(point[0], point[1]);
                        } else {
                            ctx.moveTo(point[0], point[1]);
                        }
                    });
                    ctx.stroke();
                }
            }, [strokes, currentStroke, backgroundImage, imagePosition, imageScale]);

            React.useEffect(() => {
                drawStrokes();
            }, [drawStrokes]);

            const startDrawing = (e) => {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                setCurrentStroke([[x, y, 1]]);
                lastPointRef.current = [x, y];
                lastSampledPointRef.current = [x, y];
                setIsDrawing(true);
            };

            const draw = (e) => {
                if (!isDrawing) return;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                ctx.strokeStyle = '#2F4F4F';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(lastPointRef.current[0], lastPointRef.current[1]);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                const dx = x - lastSampledPointRef.current[0];
                const dy = y - lastSampledPointRef.current[1];
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance >= SAMPLING_INTERVAL) {
                    setCurrentStroke(prev => [...prev, [x, y, 1]]);
                    lastSampledPointRef.current = [x, y];
                }
                
                lastPointRef.current = [x, y];
            };

            const endDrawing = () => {
                if (currentStroke.length > 0) {
                    setStrokes(prev => [...prev, [...currentStroke, [currentStroke[currentStroke.length - 1][0], currentStroke[currentStroke.length - 1][1], 0]]]);
                    setCurrentStroke([]);
                }
                setIsDrawing(false);
                lastPointRef.current = null;
                lastSampledPointRef.current = null;
            };

            const generateEntry = () => {
                if (!author.trim()) {
                    setErrorMessage("Please enter an author name.");
                    return null;
                }
                if (!asciiSequence.trim()) {
                    setErrorMessage("Please enter an ASCII sequence.");
                    return null;
                }
                if (strokes.length === 0) {
                    setErrorMessage("Please draw at least one stroke before adding to dataset.");
                    return null;
                }

                let allPoints = strokes.flat();
                const canvas = canvasRef.current;
                const aspectRatio = canvas.width / canvas.height;
                const normalizedPoints = allPoints.map(point => [
                    parseFloat((point[0] / canvas.width).toFixed(4)),
                    parseFloat((point[1] / canvas.height).toFixed(4)),
                    point[2]
                ]);
                
                return {
                    metadata: {author: author.trim(), asciiSequence: asciiSequence.trim(), pointCount: allPoints.length, strokeCount: strokes.length, aspectRatio},
                    points: normalizedPoints
                };
            };

            const addToDataset = () => {
                const entry = generateEntry();
                if (entry) {
                    setDataset(prev => [...prev, entry]);
                    setStrokes([]);
                    setAsciiSequence('');
                    setErrorMessage('');
                    drawStrokes();
                    return true; // Entry successfully added
                }
                return false; // Entry not added due to error
            };

            const exportDataset = () => {
                if (dataset.length === 0) {
                    setErrorMessage("The dataset is empty. Add some entries before exporting.");
                    return;
                }
                const jsonString = JSON.stringify(dataset);
                setExportedData(jsonString);
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            setBackgroundImage(img);
                            setImagePosition({ x: 0, y: 0 });
                            setImageScale(1);
                            setAsciiSequence(''); // Clear ASCII box when an image is uploaded
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handleImageMove = (direction) => {
                const step = 10;
                setImagePosition(prev => {
                    switch (direction) {
                        case 'up': return { ...prev, y: prev.y - step };
                        case 'down': return { ...prev, y: prev.y + step };
                        case 'left': return { ...prev, x: prev.x - step };
                        case 'right': return { ...prev, x: prev.x + step };
                        default: return prev;
                    }
                });
            };

            const clearAll = () => {
                setStrokes([]);
                setCurrentStroke([]);
                setErrorMessage('');
                setBackgroundImage(null); // Clear the uploaded image
                setImagePosition({ x: 0, y: 0 }); // Reset image position
                setImageScale(1); // Reset image scale
                drawStrokes();
            };

            const undo = () => {
                setStrokes(prev => prev.slice(0, -1));
            };

            const loadWordBank = () => {
                // For now, we'll use a small set of words. In a real application, you'd want to load this from an API or a larger file.


                const words = [
    // A (46 words)
    "abandon", "ability", "able", "about", "above", "abstract", "abundance", "academy", "accept", "access", "accident", "accomplish", "account", "accurate", "achieve", "acid", "acknowledge", "acorn", "acquire", "across", "act", "action", "active", "actor", "actual", "adapt", "add", "address", "adjust", "admire", "adopt", "adult", "advance", "advantage", "adventure", "advertise", "advice", "aerobic", "affair", "affect", "afford", "afraid", "again", "age", "agent", "agree",

    // B (46 words)
    "backpack", "badge", "balance", "balloon", "banana", "band", "bank", "bar", "base", "basket", "battle", "beach", "bean", "beautiful", "because", "become", "bedroom", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless",

    // C (46 words)
    "cable", "cake", "calculate", "calendar", "call", "calm", "camera", "camp", "can", "cancel", "candy", "capable", "capital", "captain", "car", "carbon", "card", "care", "career", "careful", "carry", "case", "cash", "castle", "casual", "cat", "catch", "category", "cattle", "cause", "ceiling", "celebrate", "cell", "cement", "census", "century", "ceremony", "certain", "chain", "chair", "challenge", "chance", "change", "channel", "chapter", "charge",

    // D (46 words)
    "dad", "daily", "damage", "dance", "danger", "dare", "dark", "data", "date", "daughter", "day", "deal", "dear", "debate", "debt", "decade", "decide", "decline", "decorate", "decrease", "deep", "deer", "defense", "define", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect",

    // E (46 words)
    "each", "eager", "eagle", "ear", "early", "earn", "earth", "easily", "east", "easy", "eat", "echo", "economy", "edge", "educate", "effect", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elevator", "elite", "else", "embark", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endure", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy",

    // F (46 words)
    "face", "fact", "fade", "fail", "fair", "faith", "fall", "false", "family", "famous", "fan", "fancy", "fantastic", "far", "farm", "fashion", "fast", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "fierce", "fight", "figure", "file", "fill", "film", "final", "find",

    // G (46 words)
    "gain", "galaxy", "game", "gap", "garage", "garden", "garlic", "gas", "gather", "gaze", "gear", "gene", "general", "generous", "genius", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goal", "goat", "gold", "good", "goose", "gorilla", "gossip", "govern", "grab",

    // H (46 words)
    "habit", "hair", "half", "hall", "hammer", "hand", "happy", "harbor", "hard", "harmony", "harvest", "hat", "hate", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horse",

    // I (46 words)
    "ice", "idea", "ideal", "ignore", "ill", "illegal", "imagine", "imitate", "immediate", "impact", "implement", "important", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "intend", "interest", "interior", "into", "invent",

    // J (46 words)
    "jacket", "jail", "jam", "jar", "jaw", "jazz", "jeans", "jelly", "jewel", "job", "join", "joke", "journal", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "justice", "justify", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "knowledge", "label",

    // K (46 words)
    "labor", "ladder", "lady", "lake", "lamp", "land", "language", "laptop", "large", "last", "late", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb",

    // L (46 words)
    "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple",

    // M (46 words)
    "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "medical", "meeting", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor",

    // N (46 words)
    "nail", "name", "narrow", "nation", "nature", "near", "neat", "necessary", "neck", "need", "negative", "negotiate", "neighbor", "neither", "nest", "net", "network", "neutral", "never", "new", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "nylon", "oasis", "obey", "object", "oblige",

    // O (46 words)
    "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own",

    // P (46 words)
    "pace", "pack", "page", "pain", "paint", "pair", "palace", "palm", "pan", "panel", "panic", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture",

    // Q (46 words)
    "quality", "quantity", "quarter", "queen", "question", "quick", "quiet", "quit", "quiz", "quote", "rabbit", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ranch", "random", "range", "rank", "rapid", "rare", "rate", "rather", "raven", "reach", "react", "read", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region",

    // R (46 words)
    "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "rescue", "research", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk",

    // S (46 words)
    "sad", "safe", "sail", "salad", "salary", "sale", "salt", "same", "sample", "sand", "satellite", "satisfy", "sauce", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense",

    // T (46 words)
    "table", "tackle", "tag", "tail", "take", "tale", "talk", "tall", "tank", "tap", "target", "task", "taste", "tax", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thick", "thin", "thing", "think", "third", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger",

    // U (46 words)
    "ugly", "ultimate", "umbrella", "uncle", "under", "understand", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "useful", "useless", "usual", "utility", "vacant", "vacation", "vaccine", "vacuum", "vague", "valid", "valley", "valuable", "value", "van", "vanish", "vapor", "various",

    // V (46 words)
    "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warn",

    // W (46 words)
    "wash", "waste", "watch", "water", "wave", "way", "wealth", "weapon", "wear", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood",

    // X (46 words)
    "xylophone", "xerox", "xenon", "xenophobia", "xerography", "xmas", "xray", "xylem", "xanthic", "xanadu", "xenial", "xenolithic", "xerophyte", "xylocarp", "xiphoid", "xiphosura", "xenograft", "xerosis", "xylograph", "xyster", "xystus", "xebec", "xenogenesis", "xenolith", "xerophilous", "xiphias", "xylophone", "xylorimba", "xanthoma", "xenomorph", "xerarch", "xeroderma", "xiphosura", "xylocopa", "xylitol", "xystus", "xanthophyll", "xenomania", "xerophagous", "xiphoid", "xyster", "xylol", "xylose", "xanthous", "xenon", "xerox",

    // Y (46 words)
    "yard", "year", "yell", "yellow", "yes", "yesterday", "yet", "yield", "yoga", "yogurt", "yolk", "young", "youth", "yawn", "yearbook", "yeast", "yeti", "yodel", "yoga", "yogurt", "yonder", "you", "young", "youth", "yucca", "yummy", "yacht", "yak", "yam", "yard", "yarn", "yawl", "yearn", "yeast", "yelp", "yen", "yeoman", "yew", "yield", "yippee", "yodel", "yoga", "yoke", "yolk", "yonder", "yurt",

    // Z (46 words)
    "zap", "zeal", "zebra", "zenith", "zero", "zest", "zigzag", "zinc", "zip", "zone", "zoo", "zoom", "zucchini", "zany", "zephyr", "zeppelin", "zeta", "zipper", "zodiac", "zombie", "zonal", "zoned", "zonked", "zoology", "zoom", "zounds", "zucchini", "zygote", "zealot", "zealous", "zebra", "zenith", "zephyr", "zeppelin", "zero", "zest", "zestful", "zigzag", "zinc", "zinger", "zinnia", "zip", "zircon", "zodiac", "zombie", "zone"
        ];
                setWordBank(words);
            };

            const generatePrompt = () => {
                if (wordBank.length === 0) return;

                    let prompt;
                    if (samplingMode === 'random') {
                        prompt = Array(wordCount).fill().map(() => wordBank[Math.floor(Math.random() * wordBank.length)]).join(' ');
                        setCurrentPrompt(prompt);
                    } else {
                        prompt = Array(wordCount).fill().map(() => {
                            const word = wordBank[currentIndex];
                            
                            setCurrentIndex((prevIndex) => {
                                const newIndex = (prevIndex + 1) % wordBank.length;
                                setDisplayIndex(newIndex);
                                return newIndex;
                            });

                            return word;
                        }).join(' ');
                        setCurrentPrompt(prompt);
                    }
                    if (samplingMode === 'random') {
                        setCurrentPrompt(prompt);
                    }
                setAsciiSequence(prompt); // Populate ASCII box with the prompt
            };

            React.useEffect(() => {
                loadWordBank();
            }, []);

            React.useEffect(() => {
                if (samplingMode === 'random') {
                    generatePrompt();
                } else if (wordBank.length > 0) {
                // For ordered mode, generate prompt once when wordBank is loaded
                    generatePrompt();
                }
            }, [samplingMode, wordCount, wordBank]);


            return (
                <div className="container">
                    <h2 style={{ fontSize: '24px', fontWeight: 'bold', marginBottom: '16px' }}>Handwriting Stroke Capture</h2>
                    <p style={{ fontSize: '14px', color: '#4B5563', marginBottom: '16px' }}>
                        Instructions: Upload an image, trace the writing, enter author and ASCII sequence, then add to dataset. Export when finished.
                    </p>
                    {errorMessage && <ErrorMessage message={errorMessage} />}
                    <Input
                        type="file"
                        accept="image/*"
                        onChange={handleImageUpload}
                        style={{ marginBottom: '16px' }}
                    />
                    <div style={{ marginBottom: '16px' }}>
                        <Label htmlFor="word-count">Number of Words in Prompt</Label>
                        <Input
                            id="word-count"
                            type="number"
                            min="1"
                            max="10"
                            value={wordCount}
                            onChange={(e) => {
                                const newWordCount = parseInt(e.target.value);
                                setWordCount(newWordCount);
                                 // Generate a new prompt only for random mode
                                 // or if it's the initial load for ordered mode
                                setTimeout(() => generatePrompt(), 0);
                            }}
                        />
                    </div>
                    {currentPrompt && (
                        <div style={{ 
                            marginBottom: '16px'
                        }}>
                            {currentPrompt}
                        </div>
                    )}
                    <canvas
                        ref={canvasRef}
                        width={1200}
                        height={200}
                        onMouseDown={startDrawing}
                        onMouseMove={draw}
                        onMouseUp={endDrawing}
                        onMouseOut={endDrawing}
                        style={{ border: '1px solid #CBD5E0', cursor: 'crosshair', marginBottom: '16px', maxWidth: '100%' }}
                    />

                    <div style={{ marginBottom: '16px' }}>
                        <Label htmlFor="sampling-mode">Sampling Mode</Label>
                        <div style={{ display: 'flex', alignItems: 'center' }}>
                            <Input
                                id="sampling-mode"
                                type="checkbox"
                                checked={samplingMode === 'ordered'}
                                onChange={(e) => {
                                    setSamplingMode(e.target.checked ? 'ordered' : 'random');
                                    setCurrentIndex(startIndex);
                                }}

                                style={{ marginRight: '8px' }}
                            />
                            <span>Ordered</span>
                        </div>
                    </div>
                    {samplingMode === 'ordered' && (
                        <div style={{ marginBottom: '16px' }}>
                            
                            <Label htmlFor="start-index" style={{ marginRight: '8px' }}>
                            {`Word Bank Index (current: ${displayIndex}/${wordBank.length})`}
                            </Label>
                            <Input
                                id="start-index"
                                type="number"
                                min="1"
                                max={wordBank.length}
                                value={startIndex+1}
                                onChange={(e) => {
                                    const newIndex = Math.max(0, Math.min(parseInt(e.target.value) - 1, wordBank.length - 1));
                                    setStartIndex(newIndex);
                                    setCurrentIndex(newIndex);
                                    setDisplayIndex(newIndex);
                                }}

                            />
                        </div>
                    )}

                    <div style={{ marginBottom: '16px' }}>
                        <p style={{ fontSize: '14px', color: '#4B5563', marginBottom: '8px' }}>Image Positioning Controls:</p>
                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '8px', marginBottom: '8px' }}>
                            <Button onClick={() => handleImageMove('up')}>↑</Button>
                            <Button onClick={() => handleImageMove('down')}>↓</Button>
                            <Button onClick={() => handleImageMove('left')}>←</Button>
                            <Button onClick={() => handleImageMove('right')}>→</Button>
                        </div>
                        <div>
                            <Label htmlFor="scale-slider">Image Scale</Label>
                            <Slider
                                id="scale-slider"
                                min={0.1}
                                max={2}
                                step={0.1}
                                value={imageScale}
                                onChange={(e) => setImageScale(parseFloat(e.target.value))}
                            />
                        </div>
                    </div>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '16px' }}>
                        <div>
                            <Label htmlFor="author-input">Author</Label>
                            <Input
                                id="author-input"
                                value={author}
                                onChange={(e) => setAuthor(e.target.value)}
                                placeholder="Enter author name"
                            />
                        </div>
                        <div>
                            <Label htmlFor="ascii-input">ASCII Sequence</Label>
                            <Input
                                id="ascii-input"
                                value={asciiSequence}
                                onChange={(e) => setAsciiSequence(e.target.value)}
                                placeholder="Enter ASCII sequence"
                            />
                        </div>
                    </div>
                    

                    <div style={{ display: 'flex', flexDirection: 'column', gap: '16px', marginBottom: '16px' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Button onClick={() => { clearAll(); }}>Clear All</Button>
                            <Button onClick={undo}>Undo</Button>
                            {samplingMode === 'ordered' && (
                                <Button onClick={generatePrompt}>Next Word</Button>
                            )}
                            <Button onClick={() => {
                                const success = addToDataset();
                                if (success && samplingMode === 'ordered') {
                                    setDisplayIndex((currentIndex + 1) % wordBank.length);
                                    generatePrompt();
                                }
                            }}>Add to Dataset</Button>
                        </div>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Button onClick={exportDataset}>Export Dataset</Button>
                            <span style={{ fontSize: '14px', color: '#4B5563' }}>
                                Dataset size: {dataset.length} entries
                            </span>
                        </div>
                    </div>



                    {exportedData && (
                        <Textarea
                            value={exportedData}
                            readOnly
                            placeholder="Exported dataset will appear here"
                        />
                    )}
                </div>
            );
        };

        ReactDOM.render(<HandwritingStrokeCapture />, document.getElementById('root'));
    </script>
</body>
</html>